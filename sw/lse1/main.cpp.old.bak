#include <stdbool.h>
#include <stdint.h>
#include "inc/hw_memmap.h"
#include "driverlib/debug.h"
#include "driverlib/gpio.h"
#include "driverlib/pin_map.h"
#include "driverlib/pwm.h"
#include "driverlib/rom.h"
#include "driverlib/rom_map.h"
#include "driverlib/sysctl.h"
#include "driverlib/uart.h"
#include "utils/uartstdio.h"

#ifdef DEBUG
void
__error__(char *pcFilename, uint32_t ui32Line)
{
}
#endif

#define STOP 7
#define S1 0
#define S2 1
#define S3 2
#define S4 3
#define S5 4
#define S6 5

#define RISE 0
#define FALL 1

uint8_t RiseFall = GPIO_RISING_EDGE;

void updateClosedLoopState(void){

    // Read comparator pins
    int A = MAP_GPIOPinRead(GPIO_PORTC_BASE, GPIO_PIN_4); // Comp1;
    int B = MAP_GPIOPinRead(GPIO_PORTC_BASE, GPIO_PIN_6); // Comp2;
    int C = MAP_GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_2); // Comp3;

    // Write corresponding values onto GPIOs
    MAP_PWMOutputState(PWM0_BASE, PWM_OUT_3_BIT, A * not(B)); // 1A
    MAP_PWMOutputState(PWM0_BASE, PWM_OUT_5_BIT, B * not(C)); // 2A
    MAP_PWMOutputState(PWM1_BASE, PWM_OUT_2_BIT, C * not(A)); // 3A
    
    MAP_GPIOPinWrite(PWM0_BASE, PWM_OUT_4_BIT, not(A) * B); // 1B
    MAP_GPIOPinWrite(PWM0_BASE, PWM_OUT_2_BIT, not(B) * C); // 2B
    MAP_GPIOPinWrite(PWM1_BASE, PWM_OUT_3_BIT, not(C) * A); // 3B
}

extern void GPIOInt(void) {
    RiseFall ^= 1;
}

// Configura sortides de GPIOs pels sis estats d'alimentaciÃ³ del motor
void updateState(int state){
    switch (state)
    {
        case STOP:
            MAP_PWMOutputState(PWM0_BASE, PWM_OUT_3_BIT, false); // 1A - PB5
            MAP_PWMOutputState(PWM0_BASE, PWM_OUT_5_BIT, false); // 2A - PE5
            MAP_PWMOutputState(PWM1_BASE, PWM_OUT_2_BIT, false); // 3A - PA6
            
            MAP_GPIOPinWrite(GPIO_PORTE_BASE, GPIO_PIN_4, 0x00); // 1B - PE4
            MAP_GPIOPinWrite(GPIO_PORTB_BASE, GPIO_PIN_4, 0x00); // 2B - PB4
            MAP_GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_7, 0x00); // 3B - PA7
            break;
            
        case S1:
            MAP_PWMOutputState(PWM0_BASE, PWM_OUT_3_BIT, true); // 1A
            MAP_PWMOutputState(PWM0_BASE, PWM_OUT_5_BIT, false); // 2A
            MAP_PWMOutputState(PWM1_BASE, PWM_OUT_2_BIT, false); // 3A
            
            MAP_GPIOPinWrite(GPIO_PORTE_BASE, GPIO_PIN_4, 0x00); // 1B
            MAP_GPIOPinWrite(GPIO_PORTB_BASE, GPIO_PIN_4, GPIO_PIN_4); // 2B
            MAP_GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_7, 0x00); // 3B
            break;
            
        case S2:
            MAP_PWMOutputState(PWM0_BASE, PWM_OUT_3_BIT, true); // 1A
            MAP_PWMOutputState(PWM0_BASE, PWM_OUT_5_BIT, false); // 2A
            MAP_PWMOutputState(PWM1_BASE, PWM_OUT_2_BIT, false); // 3A
            
            MAP_GPIOPinWrite(GPIO_PORTE_BASE, GPIO_PIN_4, 0x00); // 1B
            MAP_GPIOPinWrite(GPIO_PORTB_BASE, GPIO_PIN_4, 0x00); // 2B
            MAP_GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_7, GPIO_PIN_7); // 3B
            break;
            
        case S3:
            MAP_PWMOutputState(PWM0_BASE, PWM_OUT_3_BIT, false); // 1A
            MAP_PWMOutputState(PWM0_BASE, PWM_OUT_5_BIT, true); // 2A
            MAP_PWMOutputState(PWM1_BASE, PWM_OUT_2_BIT, false); // 3A
            
            MAP_GPIOPinWrite(GPIO_PORTE_BASE, GPIO_PIN_4, 0x00); // 1B
            MAP_GPIOPinWrite(GPIO_PORTB_BASE, GPIO_PIN_4, 0x00); // 2B
            MAP_GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_7, GPIO_PIN_7); // 3B
            break;
            
        case S4:
            MAP_PWMOutputState(PWM0_BASE, PWM_OUT_3_BIT, false); // 1A
            MAP_PWMOutputState(PWM0_BASE, PWM_OUT_5_BIT, true); // 2A
            MAP_PWMOutputState(PWM1_BASE, PWM_OUT_2_BIT, false); // 3A
            
            MAP_GPIOPinWrite(GPIO_PORTE_BASE, GPIO_PIN_4, GPIO_PIN_4); // 1B
            MAP_GPIOPinWrite(GPIO_PORTB_BASE, GPIO_PIN_4, 0x00); // 2B
            MAP_GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_7, 0x00); // 3B
            break;
            
        case S5:
            MAP_PWMOutputState(PWM0_BASE, PWM_OUT_3_BIT, false); // 1A
            MAP_PWMOutputState(PWM0_BASE, PWM_OUT_5_BIT, false); // 2A
            MAP_PWMOutputState(PWM1_BASE, PWM_OUT_2_BIT, true); // 3A
            
            MAP_GPIOPinWrite(GPIO_PORTE_BASE, GPIO_PIN_4, GPIO_PIN_4); // 1B
            MAP_GPIOPinWrite(GPIO_PORTB_BASE, GPIO_PIN_4, 0x00); // 2B
            MAP_GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_7, 0x00); // 3B
            break;
            
        case S6:
            MAP_PWMOutputState(PWM0_BASE, PWM_OUT_3_BIT, false); // 1A
            MAP_PWMOutputState(PWM0_BASE, PWM_OUT_5_BIT, false); // 2A
            MAP_PWMOutputState(PWM1_BASE, PWM_OUT_2_BIT, true); // 3A
            
            MAP_GPIOPinWrite(GPIO_PORTE_BASE, GPIO_PIN_4, 0x00); // 1B
            MAP_GPIOPinWrite(GPIO_PORTB_BASE, GPIO_PIN_4, GPIO_PIN_4); // 2B
            MAP_GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_7, 0x00); // 3B
            break;
    }
}


int
main(void)
{
    // Set the clocking to run directly from the external crystal/oscillator.
    MAP_SysCtlClockSet(SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_MAIN |
                       SYSCTL_XTAL_16MHZ);

    // Set the PWM clock to the system clock.
    MAP_SysCtlPWMClockSet(SYSCTL_PWMDIV_1);

    // The PWM peripheral must be enabled for use.
    // Habilitem els moduls 0 i 1 pq els necessitem els dos
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM0);
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM1);

    // Enable the GPIO port that is used for the PWM output.
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOC);
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);

    // Wait for peripherals to be ready
    while(!MAP_SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOA) ||
          !MAP_SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOB) ||
          !MAP_SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOE) ||
          !MAP_SysCtlPeripheralReady(SYSCTL_PERIPH_PWM0)  ||
          !MAP_SysCtlPeripheralReady(SYSCTL_PERIPH_PWM1));

    // Configure the PWM function for this pin
    // 1A (High-side)
    MAP_GPIOPinConfigure(GPIO_PB5_M0PWM3);
    MAP_GPIOPinTypePWM(GPIO_PORTB_BASE, GPIO_PIN_5);
    // 2A (High-side)
    MAP_GPIOPinConfigure(GPIO_PE5_M0PWM5);
    MAP_GPIOPinTypePWM(GPIO_PORTE_BASE, GPIO_PIN_5);
    // 3A (High-side)
    MAP_GPIOPinConfigure(GPIO_PA6_M1PWM2);
    MAP_GPIOPinTypePWM(GPIO_PORTA_BASE, GPIO_PIN_6);

    // Enable Low GPIOs
    MAP_GPIOPinTypeGPIOOutput(GPIO_PORTE_BASE, GPIO_PIN_4); // 1B (Low-side)
    MAP_GPIOPinTypeGPIOOutput(GPIO_PORTB_BASE, GPIO_PIN_4); // 2B (Low-side)
    MAP_GPIOPinTypeGPIOOutput(GPIO_PORTA_BASE, GPIO_PIN_7); // 3B (Low-side)

    // Enable comparator GPIOs (closed-loop)
    MAP_GPIOPinTypeGPIOInput(GPIO_PORTC_BASE, GPIO_PIN_4); // Comp1
    MAP_GPIOPinTypeGPIOInput(GPIO_PORTC_BASE, GPIO_PIN_6); // Comp2
    MAP_GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_2); // Comp3

    // Register interrupts (closed-loop)
    MAP_GPIOIntRegister(GPIO_PORTC_BASE, GPIOInt);
    MAP_GPIOIntRegister(GPIO_PORTF_BASE, GPIOInt);

    MAP_GPIOIntTypeSet(GPIO_PORTC_BASE, GPIO_PIN_6 | GPIO_PIN_4, RiseFall);
    MAP_GPIOIntTypeSet(GPIO_PORTF_BASE, GPIO_PIN_2, RiseFall);


    // Configure PWM0 to count up/down without synchronization.
    MAP_PWMGenConfigure(PWM0_BASE, PWM_GEN_1, PWM_GEN_MODE_UP_DOWN |
                        PWM_GEN_MODE_NO_SYNC); // 1A, 2B
    MAP_PWMGenConfigure(PWM0_BASE, PWM_GEN_2, PWM_GEN_MODE_UP_DOWN |
                        PWM_GEN_MODE_NO_SYNC); // 1B, 2A

    MAP_PWMGenConfigure(PWM1_BASE, PWM_GEN_1, PWM_GEN_MODE_UP_DOWN |
                        PWM_GEN_MODE_NO_SYNC); // 3A
    MAP_PWMGenConfigure(PWM1_BASE, PWM_GEN_2, PWM_GEN_MODE_UP_DOWN |
                        PWM_GEN_MODE_NO_SYNC); // 3B

    int pwm_freq = 20e3;
    // Period in clock ticks
    uint32_t ui32Period = (MAP_SysCtlClockGet() / pwm_freq);
    
    // Period for all three generators
    MAP_PWMGenPeriodSet(PWM0_BASE, PWM_GEN_1, ui32Period); // 1A (M0PWM3)
    MAP_PWMGenPeriodSet(PWM0_BASE, PWM_GEN_2, ui32Period); // 2A (M0PWM5)
    MAP_PWMGenPeriodSet(PWM1_BASE, PWM_GEN_1, ui32Period); // 3A (M1PWM2)

    float duty = 0.1;
    // Pulse width in clock ticks
    uint32_t ui32Width = (uint32_t)(ui32Period * duty);

    // Pulse Width for all three outputs
    MAP_PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, ui32Width); // 1A (PB5)
    MAP_PWMPulseWidthSet(PWM0_BASE, PWM_OUT_5, ui32Width); // 2A (PE5)
    MAP_PWMPulseWidthSet(PWM1_BASE, PWM_OUT_2, ui32Width); // 3A (PA6)

    // Enable outputs
    MAP_PWMOutputState(PWM0_BASE, PWM_OUT_3_BIT, true); // PB5 (M0PWM3)
    MAP_PWMOutputState(PWM0_BASE, PWM_OUT_5_BIT, true); // PE5 (M0PWM5)
    MAP_PWMOutputState(PWM1_BASE, PWM_OUT_2_BIT, true); // PA6 (M1PWM2)

    MAP_PWMGenEnable(PWM0_BASE, PWM_GEN_1);
    MAP_PWMGenEnable(PWM0_BASE, PWM_GEN_2);
    MAP_PWMGenEnable(PWM1_BASE, PWM_GEN_1);
    //MAP_PWMGenEnable(PWM1_BASE, PWM_GEN_2);

    // Comencem apagant tots els MOSFETs
    int state = 7;
    updateState(state);

    //
    // Loop forever while the PWM signals are generated.
    //

    float phase_period = 4e-3;

    while(1)
    {
        state += 1;
        state %= 6; // Cycle from 0 to 5 (s1 -> s6)
        
        updateState(state);
        MAP_SysCtlDelay((MAP_SysCtlClockGet() * phase_period) / 3);

        if (phase_period > 1.2e-3)
            phase_period -= 1e-6;
        else
            phase_period = 4e-3;
    }
}
