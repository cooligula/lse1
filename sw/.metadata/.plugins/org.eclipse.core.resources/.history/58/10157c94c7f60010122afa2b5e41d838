#include <stdbool.h>
#include <stdint.h>
#include "inc/hw_memmap.h"
#include "driverlib/debug.h"
#include "driverlib/gpio.h"
#include "driverlib/pin_map.h"
#include "driverlib/pwm.h"
#include "driverlib/rom.h"
#include "driverlib/rom_map.h"
#include "driverlib/sysctl.h"
#include "driverlib/uart.h"
#include "utils/uartstdio.h"
#include "mosfets.h"
#include "comparators.h"

#ifdef DEBUG
void
__error__(char *pcFilename, uint32_t ui32Line)
{
}
#endif

#define STOP 7
#define S1 0
#define S2 1
#define S3 2
#define S4 3
#define S5 4
#define S6 5

#define RISE 0
#define FALL 1



// -----------------------------------------------------
int CLOSED_LOOP = 1;
// -----------------------------------------------------


// Controller instance.
MosfetController mosfets;
ComparatorController comps;

// Max duty
float dutyMax = 0.2;

// Comencem apagant tots els MOSFETs
int state = S6;

uint8_t RiseFall = 0;

const int N = 30;

float freqfase[N+1];
float dutys[N+1];

/**
 * @brief updateClosedLoopState
 */
/*
void updateClosedLoopState() {//(bool A, bool B, bool C) {

    mosfets.Ph1A(A && !B);
    mosfets.Ph2A(B && !C);
    mosfets.Ph3A(C && !A);
    
    mosfets.Ph1B(!A && B);
    mosfets.Ph2B(!B && C);
    mosfets.Ph3B(!C && A);
}
*/

/**
 * @brief updateState
 * Configura sortides de GPIOs pels sis estats d'alimentaci√≥ del motor
 */
void updateState(int state){
    switch (state)
    {
        case STOP:
            mosfets.allOff();
            break;
            
        case S1:
            mosfets.Ph1A(true);
            mosfets.Ph2A(false);
            mosfets.Ph3A(false);
            
            mosfets.Ph1B(false);
            mosfets.Ph2B(true);
            mosfets.Ph3B(false);
            break;
            
        case S2:
            mosfets.Ph1A(true);
            mosfets.Ph2A(false);
            mosfets.Ph3A(false);
            
            mosfets.Ph1B(false);
            mosfets.Ph2B(false);
            mosfets.Ph3B(true);
            break;
            
        case S3:
            mosfets.Ph1A(false);
            mosfets.Ph2A(true);
            mosfets.Ph3A(false);
            
            mosfets.Ph1B(false);
            mosfets.Ph2B(false);
            mosfets.Ph3B(true);
            break;
            
        case S4:
            mosfets.Ph1A(false);
            mosfets.Ph2A(true);
            mosfets.Ph3A(false);
            
            mosfets.Ph1B(true);
            mosfets.Ph2B(false);
            mosfets.Ph3B(false);
            break;
            
        case S5:
            mosfets.Ph1A(false);
            mosfets.Ph2A(false);
            mosfets.Ph3A(true);
            
            mosfets.Ph1B(true);
            mosfets.Ph2B(false);
            mosfets.Ph3B(false);
            break;
            
        case S6:
            mosfets.Ph1A(false);
            mosfets.Ph2A(false);
            mosfets.Ph3A(true);
            
            mosfets.Ph1B(false);
            mosfets.Ph2B(true);
            mosfets.Ph3B(false);
            break;
    }
}

void setupNextInterrupt(int currentState) {
    comps.disableAllInterrupts();
    switch (currentState) {
        case S1: comps.configComparatorInt(COMP_3, true, GPIO_RISING_EDGE); break; // Phase C falling
        case S2: comps.configComparatorInt(COMP_2, true, GPIO_FALLING_EDGE);  break; // Phase B rising
        case S3: comps.configComparatorInt(COMP_1, true, GPIO_RISING_EDGE); break; // Phase A falling
        case S4: comps.configComparatorInt(COMP_3, true, GPIO_FALLING_EDGE);  break; // Phase C rising
        case S5: comps.configComparatorInt(COMP_2, true, GPIO_RISING_EDGE); break; // Phase B falling
        case S6: comps.configComparatorInt(COMP_1, true, GPIO_FALLING_EDGE);  break; // Phase A rising
    }

    // Clear comparator interrupts
    comps.clearInterrupts();
}


void resetStallTimer(void) {



}


bool cl_locked = false;
volatile int zc_detected_count = 0;

extern void GPIOInt(void) {
    comps.disableAllInterrupts();

    //if (cl_locked) {
        // Move to next state
    //    state = (state - 1);
    //    if (state < 0) state = 5; // Wrap around for S6
    // }

    // Update state (if operating in closed-loop)
    if (CLOSED_LOOP) {
    state = (state + 1) % 6;
    updateState(state);
    }

    // Setup next interrupt
    setupNextInterrupt(state);

    // Reset stall timer
    MAP_TimerLoadSet(TIMER0_BASE, TIMER_A, stall_check_period);


    //zc_detected_count++;
    comps.clearInterrupts();
}


void StallInt (void) {

    // Disable timer interrupts
    MAP_TimerIntDisable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);

    // Clear int.
    MAP_TimerIntClear(TIMER0_BASE, TIMER_TIMA_TIMEOUT);

    // Shut off all mosfets
    mosfets.allOff();

    // Wait the stalling grace period
    MAP_SysCtlDelay((MAP_SysCtlClockGet() * 9e-3) / 3);

    // Re-enable int.
    MAP_TimerIntEnable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);

    // Go to open-loop ramp
    goto ramp;
}


//=============================================================================
// MAIN FUNCTION
//=============================================================================
int
main(void)
{


    // Set the clocking to run directly from the external crystal/oscillator
    MAP_SysCtlClockSet(SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_MAIN |
                       SYSCTL_XTAL_16MHZ);

    // Set the PWM clock to the system clock
    MAP_SysCtlPWMClockSet(SYSCTL_PWMDIV_1);


    // Stall timer setup
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0); // Enable timer
    while(!SysCtlPeripheralReady(SYSCTL_PERIPH_TIMER0)){} // Wait for the Timer0 module to be ready.


    MAP_TimerConfigure(TIMER0_BASE, TIMER_CFG_PERIODIC); // Configure it as a periodic timer
    float stall_check_period = MAP_SysCtlClockGet() * 10e-3;
    MAP_TimerLoadSet(TIMER0_BASE, TIMER_A, stall_check_period); // Set the timer period: in this case, 10ms
    MAP_TimerIntRegister(TIMER0_BASE, TIMER_A, StallInt); // Setup the timeout handling function


    // MOSFET Setup
    float initial_duty = 0.2;
    int pwm_freq = 20e3;
    mosfets.setup(pwm_freq, initial_duty);

    // Disable interrupts, setup and reenable interrupts
    MAP_IntMasterDisable();
    comps.setup(GPIOInt);

    updateState(state); // This will now call mosfets.allOff()

    float phase_period = 4e-3;
    int cyclesPerStep = 18;

    float ini_duty = 0.18;
    float fin_duty = 0.14;
    float ini_fase = 4e-3;
    float fin_fase = 1.2e-3;
    float test_duty = 0.14 / pwm_freq;

    // Find the open-loop ramp trajectory
    for (int i=0; i<=N; i++) {
        freqfase[i] = ini_fase + (fin_fase - ini_fase) * i/N;
        dutys[i] = ini_duty + (fin_duty - ini_duty) * i/N / pwm_freq;
    }

    // Start the stalling timer
    MAP_TimerEnable(TIMER0_BASE, TIMER_A);
    MAP_TimerIntEnable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);

    MAP_IntMasterEnable();
    comps.disableAllInterrupts();

    // Rampa open loop
    ramp: for (int i = 0; i<=N; i++) {

        // Update duty
        mosfets.updateDuty(dutys[i]);

        // Wait a few phase cycles for stability
        for (int j = 0; j <= cyclesPerStep; j++){
            // Advance states
            state += 1;
            state %= 6;
            updateState(state);
            
            // Wait the corresponding phase period
            MAP_SysCtlDelay((MAP_SysCtlClockGet() * freqfase[i]) / 3);
        }

    }


    if (!CLOSED_LOOP) {

        //freqfase[N] = 0.9e-3;

        while (1) {
            state += 1;
            state %= 6;
            updateState(state);

            MAP_SysCtlDelay((MAP_SysCtlClockGet() * freqfase[N]) / 3);
        }
    } else {
    // A PARTIR D'AQUI CLOSED LOOP

        // Enable interrupts but DON'T stop the loop yet
        MAP_IntMasterEnable();
        comps.clearInterrupts();
        // Start looking for the first ZC
        setupNextInterrupt(state);

        //while (!cl_locked) {
            // Keep commutating at the final frequency
        //    state = (state + 1) % 6;
        //    updateState(state);
        //    setupNextInterrupt(state); // Ensure comparator is looking for the right edge

            // Wait the phase period from the end of the ramp
            //MAP_SysCtlDelay((MAP_SysCtlClockGet() * freqfase[N]) / 3);

            // If we've seen enough interrupts in the ISR -> stop this manual loop
        //    if (zc_detected_count > 12) { // Wait for 2 full revS
        //        cl_locked = true;
        //    }
        while (1) {}
        }
}
