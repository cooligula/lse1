//*****************************************************************************

#include <stdint.h>
#include <stdbool.h>
#include "inc/hw_memmap.h"
#include "driverlib/debug.h"
#include "driverlib/gpio.h"
#include "driverlib/adc.h"
#include "driverlib/pwm.h"
#include "driverlib/pin_map.h"
#include "driverlib/sysctl.h"
//#include "basic_conf.h"
#include "driverlib/interrupt.h"

//*****************************************************************************
//
//! \addtogroup example_list
//! <h1>Blinky (blinky)</h1>
//!
//! A very simple example that blinks the on-board LED using direct register
//! access.
//
//*****************************************************************************

//*****************************************************************************
//
// The error routine that is called if the driver library encounters an error.
//
//*****************************************************************************
#ifdef DEBUG
void
__error__(char *pcFilename, uint32_t ui32Line)
{
    while(1);
}
#endif


uint32_t ADC0_ReadAverage(uint8_t samples)
{
    uint32_t sum = 0;
    uint32_t value;
    volatile uint8_t i = 0;
    for(i = 0; i < samples; i++)
    {
        // Trigger SS3 conversion
        ADCProcessorTrigger(ADC0_BASE, 3);

        // Read the ADC value
        ADCSequenceDataGet(ADC0_BASE, 3, &value);
        sum += value;  // Use single-read function
    }
    return sum / samples;
}


int main(void)
{
    volatile uint32_t ui32Loop;

    // Set the clocking to run directly from the external crystal/oscillator
    SysCtlClockSet(SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_MAIN |
    SYSCTL_XTAL_16MHZ);

    // Set the PWM clock to the system clock
    SysCtlPWMClockSet(SYSCTL_PWMDIV_1);

    //
    // Enable the GPIO port that is used for the on-board LED.
    //
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);

    //
    // Check if the peripheral access is enabled.
    //
    while (!SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOF))
    {
    }

    // Enable ADC0 and GPIOE clocks
    SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);

    // Wait until peripherals are ready
    while(!SysCtlPeripheralReady(SYSCTL_PERIPH_ADC0));
    while(!SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOE));
    // Configure PE3 as an ADC input (AIN0)
    GPIOPinTypeADC(GPIO_PORTE_BASE, GPIO_PIN_3);

    // Disable SS3 before configuration
    ADCSequenceDisable(ADC0_BASE, 3);
    // Configure SS3 for processor trigger, highest priority
    ADCSequenceConfigure(ADC0_BASE, 3, ADC_TRIGGER_PROCESSOR, 0);
    // Configure SS3 step 0 to read AIN0
    // ADC_CTL_END marks the end of the sequence
    ADCSequenceStepConfigure(ADC0_BASE, 3, 0, ADC_CTL_CH0 | ADC_CTL_END);
    ADCSequenceEnable(ADC0_BASE, 3);   // Enable SS3


    // PWM enable & setup
    SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM1); // Farem servir el modul 1, ja que el pin PF3 te M1PWM7
    GPIOPinConfigure(GPIO_PF3_M1PWM7);
    GPIOPinTypePWM(GPIO_PORTF_BASE, GPIO_PIN_3);

    float pwm_freq = 20e3;
    uint32_t ui32Period = (SysCtlClockGet() / pwm_freq);

    PWMGenConfigure(PWM1_BASE, PWM_GEN_3, PWM_GEN_MODE_UP_DOWN |
                            PWM_GEN_MODE_NO_SYNC);
    PWMGenPeriodSet(PWM1_BASE, PWM_GEN_3, ui32Period); // GENERADOR 3 O 4 IDK

    // Pulse width in clock ticks
    float duty_cycle = 0.5;
    uint32_t ui32Width = (uint32_t) (ui32Period * duty_cycle);

    // Pulse Width for all three outputs
    PWMPulseWidthSet(PWM1_BASE, PWM_OUT_7_BIT, ui32Width);
    PWMGenEnable(PWM1_BASE, PWM_GEN_3);


    //
    // Enable the GPIO pin for the LED (PF3).  Set the direction as output, and
    // enable the GPIO pin for digital function.
    //
    GPIOPinTypeGPIOOutput(GPIO_PORTC_BASE, GPIO_PIN_4); // PF3

    // Enable the reference voltage pin
    GPIOPinWrite(GPIO_PORTC_BASE, GPIO_PIN_4, GPIO_PIN_4);
    //PWMPulseWidthSet(PWM1_BASE, PWM_OUT_7, ui32Width);

    IntMasterEnable();

    PWMOutputState(PWM1_BASE, PWM_OUT_7_BIT, true);

    //
    // Loop forever.
    //
    while (1)
    {
        // Read potentiometer position
        ui32Width = ADC0_ReadAverage(5) / 4095.0;

        // Update PWM value
        //PWMPulseWidthSet(PWM1_BASE, PWM_OUT_7, ui32Width);

        // Small delay
        SysCtlDelay((SysCtlClockGet() * 1e-3) / 3);
    }
}
