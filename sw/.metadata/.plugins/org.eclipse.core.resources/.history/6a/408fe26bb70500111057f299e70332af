#include <stdbool.h>
#include <stdint.h>
#include "inc/hw_memmap.h"
#include "driverlib/debug.h"
#include "driverlib/gpio.h"
#include "driverlib/pin_map.h"
#include "driverlib/pwm.h"
#include "driverlib/rom.h"
#include "driverlib/rom_map.h"
#include "driverlib/sysctl.h"
#include "driverlib/uart.h"
#include "driverlib/timer.h"
#include "driverlib/fpu.h"
#include "utils/uartstdio.h"
#include "mosfets.h"
#include "comparators.h"
#include "adc.h"

#ifdef DEBUG
void
__error__(char *pcFilename, uint32_t ui32Line)
{
}
#endif
volatile int calibrating = 0; // New flag to tell ISR what to do
#define LUT_SIZE 20 // 5% steps from 0% to 100%
// Index 0 = 0% Duty, Index 19 = 95% Duty
float OptimalDelayLUT[LUT_SIZE];

// Default initialization (Standard 30 degrees = 0.5 factor of a 60 deg step)
void InitLUT() {
    for(int i=0; i<LUT_SIZE; i++) {
        OptimalDelayLUT[i] = 0.5f;
    }
}

#define STOP 7
#define S1 0
#define S2 1
#define S3 2
#define S4 3
#define S5 4
#define S6 5

#define RISE 0
#define FALL 1

// ---------------------------------------------------
int CLOSED_LOOP = 1;
// -----------------------------------------------------
int stall_detect = 0;
// -----------------------------------------------------
int potentiometer = 1;
// -----------------------------------------------------
int PID_control = 1;
// -----------------------------------------------------
int legacy = 0;
// -----------------------------------------------------


// ---------------------------------------------------------------------------
volatile uint32_t last_commutation_time = 0;
volatile float adaptive_delay_factor = 0.50f; // Start at neutral (30 degrees)
// ---------------------------------------------------------------------------

// Controller instance.
MosfetController mosfets;
ComparatorController comps;

volatile float global_delay_factor;

// Max duty
int pwm_freq = 20e3;
uint32_t ui32Period;

// Stalling timer period
uint32_t stallPeriod;
// Counter to track interrupt activity
volatile uint32_t isr_execution_count = 0;
volatile int commutation_error_count = 0;

// Stores the time (in clock ticks) between the last two commutation steps
volatile uint32_t measuredTicks = 0;

// PID variables
volatile float error = 0.0f;
volatile float errAcum = 0.0f;
volatile float errPrev = 0.0f;
volatile float setpoint = 0.0f;
float DutyMinLim = 0.12f;
float DutyMaxLim = 0.91f;
float TFaseMax = 0.45e-3f; // s
float TFaseMin = 0.2e-3f; // s
volatile float NoLoadDuty = 0.0f;
volatile float PID_Duty = 0.0f;
volatile uint8_t counter = 0;

// Current Duty Cycle State (Start at a safe middle value, e.g., 14%)
float current_duty_percent = 0.14;

// Controller Limits
#define MIN_DUTY_CLAMP 0.14f // 12%
#define MAX_DUTY_CLAMP 0.22f // 18%

// Comencem apagant tots els MOSFETs
int state = STOP;

uint8_t RiseFall = 0;
uint8_t calibrated = 0;

// Number of cycles in OL ramp
const int N = 30;

// OL ramp parameter vectors
float freqfase[N + 1];
uint32_t dutys[N + 1];

// Dynamic status variables
volatile int started = 0;
volatile int moving = 1;

uint32_t target_ticks = 0;
uint32_t adc_val = 0;

/**
 * @brief updateClosedLoopState
 */
/*
 void updateClosedLoopState() {//(bool A, bool B, bool C) {

 mosfets.Ph1A(A && !B);
 mosfets.Ph2A(B && !C);
 mosfets.Ph3A(C && !A);

 mosfets.Ph1B(!A && B);
 mosfets.Ph2B(!B && C);
 mosfets.Ph3B(!C && A);
 }
 */

/**
 * @brief updateState
 * Configura sortides de GPIOs pels sis estats d'alimentaciÃ³ del motor
 */
void updateState(int state)
{
    switch (state)
    {
    case STOP:
        mosfets.allOff();
        break;

    case S1:
        mosfets.Ph1A(true);
        mosfets.Ph2A(false);
        mosfets.Ph3A(false);

        mosfets.Ph1B(false);
        mosfets.Ph2B(true);
        mosfets.Ph3B(false);
        break;

    case S2:
        mosfets.Ph1A(true);
        mosfets.Ph2A(false);
        mosfets.Ph3A(false);

        mosfets.Ph1B(false);
        mosfets.Ph2B(false);
        mosfets.Ph3B(true);
        break;

    case S3:
        mosfets.Ph1A(false);
        mosfets.Ph2A(true);
        mosfets.Ph3A(false);

        mosfets.Ph1B(false);
        mosfets.Ph2B(false);
        mosfets.Ph3B(true);
        break;

    case S4:
        mosfets.Ph1A(false);
        mosfets.Ph2A(true);
        mosfets.Ph3A(false);

        mosfets.Ph1B(true);
        mosfets.Ph2B(false);
        mosfets.Ph3B(false);
        break;

    case S5:
        mosfets.Ph1A(false);
        mosfets.Ph2A(false);
        mosfets.Ph3A(true);

        mosfets.Ph1B(true);
        mosfets.Ph2B(false);
        mosfets.Ph3B(false);
        break;

    case S6:
        mosfets.Ph1A(false);
        mosfets.Ph2A(false);
        mosfets.Ph3A(true);

        mosfets.Ph1B(false);
        mosfets.Ph2B(true);
        mosfets.Ph3B(false);
        break;
    }
}

void CalibrateTiming() {
    // Disable PID and Safety
    PID_control = 0;
    potentiometer = 0; // Ignore pot
    calibrating = 1;

    // Sweep Parameters
    float start_duty = 0.15f; // Start above stall voltage
    float end_duty = 0.80f;
    float duty_step = 0.05f;  // 5% steps

    // Factor range to test: 0.1 (Advance) to 0.9 (Retard)
    // 0.5 is neutral (30 degrees)
    float start_factor = 0.1f;
    float end_factor = 0.9f;
    float factor_step = 0.01f;

    for (float d = start_duty; d <= end_duty; d += duty_step) {

        // A. Set Fixed Duty
        uint32_t duty_ticks = (uint32_t)(d * ui32Period);
        mosfets.updateDuty(duty_ticks);

        // Wait for speed to stabilize (huge delay)
        MAP_SysCtlDelay(MAP_SysCtlClockGet() * 1.0f); // 3 seconds?

        // B. Optimization Sweep
        float best_factor = 0.5f;
        uint32_t min_period = 0xFFFFFFFF; // Inverse of speed (Lower is better)

        for (float k = start_factor; k <= end_factor; k += factor_step) {

            // Set the global variable used by GPIOInt
            // You need to declare 'volatile float global_delay_factor' in main.cpp
            global_delay_factor = k;

            // Wait a bit for the motor to settle on this new timing
            MAP_SysCtlDelay(MAP_SysCtlClockGet() * 0.1f);

            // Capture Average Speed (Read 'measuredTicks' from ISR)
            uint32_t avg_period = 0;
            for(int n=0; n<10; n++) {
                avg_period += measuredTicks;
                MAP_SysCtlDelay(MAP_SysCtlClockGet() * 0.01f);
            }
            avg_period /= 10;

            // Is this the fastest so far?
            if (avg_period < min_period) {
                min_period = avg_period;
                best_factor = k;
            }
        }

        // C. Save to LUT
        int index = (int)(d * 20.0f); // Map 0.15 -> Index 3
        if(index < LUT_SIZE) {
            OptimalDelayLUT[index] = best_factor;
        }
    }

    // 4. Restore
    PID_control = 1;
    potentiometer = 1;
}

void setupNextInterrupt(int currentState)
{
    comps.disableAllInterrupts();
    switch (currentState)
    {
    case STOP: // Equivalent a S6
        comps.configComparatorInt(COMP_1, true, GPIO_RISING_EDGE);
        break; // Phase A rising
    case S1:
        comps.configComparatorInt(COMP_3, true, GPIO_FALLING_EDGE);
        break; // Phase C falling
    case S2:
        comps.configComparatorInt(COMP_2, true, GPIO_RISING_EDGE);
        break; // Phase B rising
    case S3:
        comps.configComparatorInt(COMP_1, true, GPIO_FALLING_EDGE);
        break; // Phase A falling
    case S4:
        comps.configComparatorInt(COMP_3, true, GPIO_RISING_EDGE);
        break; // Phase C rising
    case S5:
        comps.configComparatorInt(COMP_2, true, GPIO_FALLING_EDGE);
        break; // Phase B falling
    case S6:
        comps.configComparatorInt(COMP_1, true, GPIO_RISING_EDGE);
        break; // Phase A rising
    }

    // Clear comparator interrupts
    comps.clearInterrupts();
}

float PID(float cycleTime, float error, float errPrev, float errAcum)
{
    float K_p = 10000.0f;
    float K_i = 30000.0f; //50000.0f; //3*K_p;
    float K_d = 0.0f;

    return K_p * error + K_i * errAcum + K_d * (error - errPrev) / cycleTime;
}

/**
 * Reads the raw comparator states to determine the physical rotor sector (S1-S6).
 * This allows the code to "find" the rotor if it gets lost.
 */
int getRealRotorState(void)
{
    // Read the raw boolean state of the comparators using your existing library
    bool A = comps.readA();
    bool B = comps.readB();
    bool C = comps.readC();

    // Combine into a 3-bit Hall-style code (A | B | C)
    int hallCode = (A << 2) | (B << 1) | (C << 0);

    // Map the 3-bit code to your S1-S6 states based on your commutation table
    switch (hallCode)
    {
    case 5:
        return S1; // 101 -> S1 (Wait for C Fall)
    case 4:
        return S2; // 100 -> S2 (Wait for B Rise)
    case 6:
        return S3; // 110 -> S3 (Wait for A Fall)
    case 2:
        return S4; // 010 -> S4 (Wait for C Rise)
    case 3:
        return S5; // 011 -> S5 (Wait for B Fall)
    case 1:
        return S6; // 001 -> S6 (Wait for A Rise)
    default:
        return -1; // Invalid state (000 or 111)
    }
}

// Reads a TFase value (such as the setpoint) and returns the duty value for no torque
float TFaseToDuty(float TFase)
{
    float instDuty = -6186719601.0f * TFase * TFase * TFase;
    instDuty += 16659072.0f * TFase * TFase;
    instDuty += -15016.0f * TFase + 4.675f;
    return instDuty;
}

void CalculateLimits() {
    // Clamp lowest speed (polynomial is flat at low speeds)
    TFaseMax = 4.5e-3;

    float required_startup_duty = TFaseToDuty(TFaseMax);
    if (required_startup_duty > DutyMinLim) {
        DutyMinLim = required_startup_duty; // Auto-raise the floor
    }


    // The polynomial is usually good here. We find the period for 80% duty.
    float test_period = 2.0e-3; // Start search from our new slow limit
    while (test_period > 0.1e-3) {
        // We look for the moment the predicted duty crosses our Max Limit
        if (TFaseToDuty(test_period) >= DutyMaxLim) {
            TFaseMin = test_period;
            break;
        }
        test_period -= 0.01e-3; // Step down by 10us
    }
}

bool cl_locked = false;
volatile int zc_detected_count = 0;

extern void GPIOInt(void)
{
    // ---------------------------------------------------------
    // 1. CAPTURE TIME (CRITICAL FOR SYMMETRY)
    // ---------------------------------------------------------
    // Capture time immediately. Timer counts DOWN.
    uint32_t current_timer_value = MAP_TimerValueGet(TIMER0_BASE, TIMER_A);

    // Calculate time elapsed since the LAST commutation event.
    // This is "Time from Commutation to Zero Crossing" (T_comm_to_zc)
    // Handle timer wrap-around if necessary (though stallPeriod usually resets it).
    // Assuming Timer Load is 'stallPeriod' and it counts down:
    uint32_t time_since_last_comm = 0;

    if (last_commutation_time >= current_timer_value) {
        time_since_last_comm = last_commutation_time - current_timer_value;
    } else {
        // Handle wrap-around (Timer reached 0 and reloaded)
        time_since_last_comm = (last_commutation_time + stallPeriod) - current_timer_value;
    }

    comps.disableAllInterrupts();

    // ---------------------------------------------------------
    // 2. SYNC & SAFETY CHECKS (LEGACY SUPPORT)
    // ---------------------------------------------------------
    if (legacy)
    {
        int realState = getRealRotorState();
        if (realState != -1 && realState != state
                && realState != (state + 1) % 6)
        {
            state = realState;
            updateState(state);
            commutation_error_count++;
            // If we forced a state change, reset our timing tracker
            last_commutation_time = current_timer_value;
        }
        else
        {
            if (commutation_error_count > 0) commutation_error_count--;
        }
    }

    isr_execution_count++;

    // Calculate total period (Speed) for PID
    // 'measuredTicks' is usually the time between two ZC events or two commutations.
    // Here we estimate it as 2x the time_since_last_comm because we are at the halfway point (ideally).
    measuredTicks = time_since_last_comm * 2;

    // ---------------------------------------------------------
    // 3. ADAPTIVE TIMING CORRECTION (THE MAGIC)
    // ---------------------------------------------------------

    // We want the delay to be exactly equal to the time it took to get here.
    // If we wait exactly 'time_since_last_comm', we are commutating at the
    // exact mirror image of the ZC point.

    uint32_t delay_ticks = time_since_last_comm;

    // OPTIONAL: Fine-tune the factor based on previous error
    // If you want to use the 'adaptive_delay_factor' variable to slightly
    // advance/retard based on high-speed lag:

    // delay_ticks = (uint32_t)(time_since_last_comm * adaptive_delay_factor);

    // Since 'time_since_last_comm' IS the reference, we can just use it directly
    // for a pure 0.5 (Symmetric) approach.

    // However, if you want to COMPENSATE for CPU overhead, we can subtract a fixed constant:
    // uint32_t overhead_ticks = 150; // Approx 2-3us at 80MHz?
    // if (delay_ticks > overhead_ticks) delay_ticks -= overhead_ticks;


    // ---------------------------------------------------------
    // 4. APPLY DELAY
    // ---------------------------------------------------------
    if (delay_ticks > 0) {
        MAP_SysCtlDelay(delay_ticks / 3); // SysCtlDelay is 3 cycles per loop
    }

    // ---------------------------------------------------------
    // 5. PID CALCULATION (SPEED CONTROL)
    // ---------------------------------------------------------
    if (PID_control && !calibrating)
    {
        float cycleTime = (float) measuredTicks / (float) MAP_SysCtlClockGet();

        // Standard PID Logic
        error = cycleTime - setpoint;
        errAcum += error * cycleTime;

        // Anti-windup clamping
        if (errAcum > 0.00002f) errAcum = 0.00002f;
        if (errAcum < -0.00002f) errAcum = -0.00002f;

        // Calculate Duty
        PID_Duty = NoLoadDuty + PID(cycleTime, error, errPrev, errAcum);

        // Safety Clamps
        if (PID_Duty > DutyMaxLim) PID_Duty = DutyMaxLim;
        else if (PID_Duty < DutyMinLim) PID_Duty = DutyMinLim;

        uint32_t newDuty = (uint32_t) (PID_Duty * ui32Period);
        mosfets.updateDuty(newDuty);

        errPrev = error;
    }

    // ---------------------------------------------------------
    // 6. COMMUTATION
    // ---------------------------------------------------------
    if (CLOSED_LOOP && started)
    {
        state = (state + 1) % 6;
        updateState(state);

        // ** CRITICAL: SAVE TIME OF COMMUTATION **
        // We capture the timer right after the switch to serve as the baseline
        // for the NEXT interrupt.
        last_commutation_time = MAP_TimerValueGet(TIMER0_BASE, TIMER_A);
    }

    // ---------------------------------------------------------
    // 7. HOUSEKEEPING (Reset Timer & Interrupts)
    // ---------------------------------------------------------
    // Reset stall timer watchdog
    MAP_TimerIntDisable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
    MAP_TimerLoadSet(TIMER0_BASE, TIMER_A, stallPeriod);
    MAP_TimerIntEnable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);

    setupNextInterrupt(state);
    comps.clearInterrupts();
}

void StallInt(void)
{

// Disable timer interrupts
    MAP_TimerIntDisable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);

// Clear int.
    MAP_TimerIntClear(TIMER0_BASE, TIMER_TIMA_TIMEOUT);

// Shut off all mosfets
    mosfets.allOff();

// Wait the stalling grace period
    MAP_SysCtlDelay((MAP_SysCtlClockGet() * 300e-3) / 3);

// Notify of stalling
    moving = 0;
    started = 0;
    state = STOP;

// Re-enable int.
    MAP_TimerIntEnable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
}

//=============================================================================
// MAIN FUNCTION
//=============================================================================
int main(void)
{

// Set the clocking to run directly from the external crystal/oscillator
    MAP_SysCtlClockSet(SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_MAIN |
    SYSCTL_XTAL_16MHZ);
    ui32Period = (uint32_t) (MAP_SysCtlClockGet() / pwm_freq);

// Set the PWM clock to the system clock
    MAP_SysCtlPWMClockSet(SYSCTL_PWMDIV_1);

// Enable FPU
    FPUEnable();
    FPULazyStackingEnable();

// Stall timer setup
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0); // Enable timer
    while (!SysCtlPeripheralReady(SYSCTL_PERIPH_TIMER0))
    {
    }; // Wait for the Timer0 module to be ready
    MAP_TimerConfigure(TIMER0_BASE, TIMER_CFG_PERIODIC); // Configure it as a periodic timer
    stallPeriod = MAP_SysCtlClockGet() * 1; // NO SE PER QUE PERO AIXO FUNCIONA
    MAP_TimerLoadSet(TIMER0_BASE, TIMER_A, stallPeriod); // Set the timer period: in this case, 10ms?
    TimerIntRegister(TIMER0_BASE, TIMER_A, StallInt); // Set up the timeout handling function

// ADC setup
    ADCSetup();

// MOSFET Setup
    float initial_duty = 0.16;
    mosfets.setup(pwm_freq, initial_duty);

// Disable interrupts for setup
    MAP_IntMasterDisable();
    comps.setup(GPIOInt);

    updateState(state); // This will now call mosfets.allOff()

// Calculate limits
    //CalculateLimits();

//float phase_period = 4e-3;
    int cyclesPerStep = 32;

    float ini_duty = 0.18;
    float fin_duty = 0.14;
    float ini_fase = 4e-3; // ms
    float fin_fase = 1.5e-3; // ms
// float test_duty = 0.14 / pwm_freq;

// Find the open-loop ramp trajectory
    for (int i = 0; i <= N; i++)
    {
        freqfase[i] = (ini_fase + (fin_fase - ini_fase) * i / N) / 2;
        dutys[i] = (uint32_t) (ui32Period
                * (ini_duty + (fin_duty - ini_duty) * i / N));
    }

    MAP_IntMasterEnable();
    comps.clearInterrupts();
    comps.disableAllInterrupts();

// Start the stalling timer
    MAP_TimerEnable(TIMER0_BASE, TIMER_A);
    if (stall_detect)
    {
        MAP_TimerEnable(TIMER0_BASE, TIMER_A);
        //MAP_TimerIntEnable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
        // setupNextInterrupt(state);
    }

// Variable to track the last seen ISR count
    uint32_t last_isr_count = 0;
// Timeout counter to detect a stall/manual spin
    uint32_t manual_spin_timeout = 0;

    while (1)
    {

        if (!started)
        {
            // Disable interrupts for ramp
            MAP_TimerIntDisable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);

            comps.disableAllInterrupts();
            comps.clearInterrupts();

            moving = 1;

            state = S6;
            updateState(state);
            MAP_SysCtlDelay((MAP_SysCtlClockGet() * 500e-3) / 3); // Hold for 500ms

            // Rampa open loop
            for (int i = 0; i <= N; i++)
            {

                // Update duty
                mosfets.updateDuty(dutys[i]);

                // Wait a few phase cycles for stability
                for (int j = 0; j <= cyclesPerStep; j++)
                {
                    // Advance states
                    state += 1;
                    state %= 6;
                    updateState(state);

                    // Wait the corresponding phase period
                    MAP_SysCtlDelay((MAP_SysCtlClockGet() * freqfase[i]) / 3);

                    if (!moving)
                    {
                        break;
                        //moving = 1;
                    }
                }
                if (!moving)
                {
                    moving = 1;
                    break;
                }

            }

            float ramp_end_period = freqfase[N];
            setpoint = ramp_end_period;

            NoLoadDuty = (float)dutys[N] / (float)ui32Period;

            errAcum = 0.0f;
            error = 0.0f;
            errPrev = 0.0f;

            PID_Duty = fin_duty;
            errAcum = 0.0f;
            started = 1;
        }
        else if (!CLOSED_LOOP)
        {
            state += 1;
            state %= 6;
            updateState(state);

            MAP_SysCtlDelay((MAP_SysCtlClockGet() * freqfase[N]) / 3);
            //setupNextInterrupt(state);
        }
        else
        {
            // A PARTIR D'AQUI CLOSED LOOP

            if (started != 2)
            {
                comps.clearInterrupts();
                MAP_TimerIntClear(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
                MAP_TimerLoadSet(TIMER0_BASE, TIMER_A, stallPeriod);
                measuredTicks = 0;

                setupNextInterrupt(state);
                started = 2;
            }

            if (potentiometer && calibrated)
            {
                if (PID_control) // Potentiometer sets setpoint
                {
                    /*
                    setpoint = (TFaseMin - TFaseMax) * (float) ADC0_ReadAvg(5)
                            / 4095.0f + TFaseMax; // Expected phase period
                    NoLoadDuty = TFaseToDuty(setpoint); // Observed duty under no load

                    if (NoLoadDuty < DutyMinLim) NoLoadDuty = DutyMinLim;
                    if (NoLoadDuty > DutyMaxLim) NoLoadDuty = DutyMaxLim;

                    //float setFloat = (TFaseMin - TFaseMax) * (float) ADC0_ReadAvg(5) / 4095.0 + TFaseMax;
                    //setpoint = setFloat * MAP_SysCtlClockGet(); // This allows us to compare TFase to counted ticks
                     *
                     */
                    float raw_target = (TFaseMin - TFaseMax) * (float)ADC0_ReadAvg(5) / 4095.0f + TFaseMax;

                    // Instead of jumping instantly, move 'setpoint' slowly towards 'raw_target'
                    // Simulates physical inertia of the rotor
                    float max_step = 0.00005f; // 50us per interrupt step. Adjust for acceleration feel.

                    if (setpoint > raw_target + max_step) {
                        setpoint -= max_step; // Speeding up (Period decreasing)
                    }
                    else if (setpoint < raw_target - max_step) {
                        setpoint += max_step; // Slowing down (Period increasing)
                    }
                    else {
                        setpoint = raw_target; // Close enough
                    }

                    // Recalculate FeedForward based on the RAMPHED setpoint
                    NoLoadDuty = TFaseToDuty(setpoint);

                    if (NoLoadDuty < DutyMinLim) NoLoadDuty = DutyMinLim;
                    if (NoLoadDuty > DutyMaxLim) NoLoadDuty = DutyMaxLim;
                }
                else
                {
                    // Direct potentiometer calculation
                    float readDuty = ((float) ADC0_ReadAvg(5) / 4095.0f)
                            * (DutyMaxLim - DutyMinLim) + DutyMinLim;
                    uint32_t newDuty = (uint32_t) (readDuty * ui32Period);

                    mosfets.updateDuty(newDuty);

                    MAP_SysCtlDelay(MAP_SysCtlClockGet() * 10e-3);
                }
            }
            else
           {
               //CalibrateTiming();
               calibrated = 1;
               calibrating = 0;
           }

            /*if (potentiometer) // && started == 2)
             {
             // 1. DETERMINE TARGET SPEED FROM POTENTIOMETER
             // Map ADC (0-4095) to a Target Period (Time per step in ticks)
             // High ADC = Fast Speed = Low Period
             // Low ADC  = Slow Speed = High Period

             adc_val = ADC0_ReadAvg(5);

             uint32_t min_speed_ticks = 8000;
             uint32_t max_speed_ticks = 3000;

             target_ticks = min_speed_ticks
             - ((adc_val * (min_speed_ticks - max_speed_ticks))
             / 4095);

             // CALCULATE ERROR AND ADJUST DUTY (Integral Control)
             // "Deadband" is a small margin of error (e.g. 2000 ticks) where we don't change anything
             // to prevent the motor from "hunting" (revving up and down).
             if (legacy)
             {
             uint32_t deadband = 50;
             float step_size = 0.0001f; // How fast it reacts. Too big = unstable.

             if (measured_ticks > (target_ticks + deadband))
             {
             // Motor is taking TOO LONG (Too Slow) -> Increase Power
             current_duty_percent += step_size;
             }
             else if (measured_ticks < (target_ticks - deadband))
             {
             // Motor is taking TOO LITTLE TIME (Too Fast) -> Decrease Power
             current_duty_percent -= step_size;
             }

             // Clamping
             if (current_duty_percent > MAX_DUTY_CLAMP)
             current_duty_percent = MAX_DUTY_CLAMP;
             if (current_duty_percent < MIN_DUTY_CLAMP)
             current_duty_percent = MIN_DUTY_CLAMP;
             }

             // Apply new duty
             uint32_t newDuty =
             (uint32_t) (current_duty_percent * ui32Period);
             mosfets.updateDuty(newDuty);

             // Small delay to keep the control loop stable
             MAP_SysCtlDelay(MAP_SysCtlClockGet() * 5e-3);
             }
             */
            if (legacy)
            {
                if (isr_execution_count == last_isr_count)
                {
                    // No interrupts have fired recently -> Potential stall or manual spin
                    manual_spin_timeout++;

                    // If we have been "silent" for enough loop cycles
                    if (manual_spin_timeout > 10)
                    {
                        MAP_IntMasterDisable();
                        comps.disableAllInterrupts();
                        comps.clearInterrupts();

                        mosfets.allOff();
                        state = S6;
                        started = 0;

                        MAP_IntMasterEnable();
                        // Reset timeout so we don't spam the resync
                        manual_spin_timeout = 0;
                    }
                }
                else if (commutation_error_count > 5)
                {
                    // We get interrupts but wrong ones

                    MAP_IntMasterDisable();
                    comps.disableAllInterrupts();
                    comps.clearInterrupts();

                    mosfets.allOff();
                    state = S6;
                    started = 0;

                    // Reset counters
                    manual_spin_timeout = 0;
                    commutation_error_count = 0;
                    last_isr_count = 0;

                    MAP_IntMasterEnable();
                }
                else
                {
                    // Interrupts are firing! The motor is running normally.
                    // Reset the timeout and update our tracker.
                    manual_spin_timeout = 0;
                    last_isr_count = isr_execution_count;
                }
            }

            //while (!cl_locked) {
            // Keep commutating at the final frequency
            //    state = (state + 1) % 6;
            //    updateState(state);
            //    setupNextInterrupt(state); // Ensure comparator is looking for the right edge

            // Wait the phase period from the end of the ramp
            //MAP_SysCtlDelay((MAP_SysCtlClockGet() * freqfase[N]) / 3);

            // If we've seen enough interrupts in the ISR -> stop this manual loop
            //    if (zc_detected_count > 12) { // Wait for 2 full revS
            //        cl_locked = true;
            //    }
            //while (1) {}
        }
    }
}
