#include <stdbool.h>
#include <stdint.h>
#include "inc/hw_memmap.h"
#include "driverlib/debug.h"
#include "driverlib/gpio.h"
#include "driverlib/pin_map.h"
#include "driverlib/pwm.h"
#include "driverlib/rom.h"
#include "driverlib/rom_map.h"
#include "driverlib/sysctl.h"
#include "driverlib/uart.h"
#include "driverlib/timer.h"
#include "driverlib/fpu.h"
#include "utils/uartstdio.h"
#include "mosfets.h"
#include "comparators.h"
#include "adc.h"

#ifdef DEBUG
void
__error__(char *pcFilename, uint32_t ui32Line)
{
}
#endif

#define STOP 7
#define S1 0
#define S2 1
#define S3 2
#define S4 3
#define S5 4
#define S6 5

#define RISE 0
#define FALL 1

// -----------------------------------------------------
int CLOSED_LOOP = 1;
// -----------------------------------------------------
int stall_detect = 0;
// -----------------------------------------------------
int potentiometer = 1;
// -----------------------------------------------------
int PID_control = 1;
// -----------------------------------------------------
int legacy = 0;
// -----------------------------------------------------

// Controller instance.
MosfetController mosfets;
ComparatorController comps;

// Max duty
int pwm_freq = 20e3;
uint32_t ui32Period;

// Stalling timer period
uint32_t stallPeriod;
// Counter to track interrupt activity
volatile uint32_t isr_execution_count = 0;
volatile int commutation_error_count = 0;

// Stores the time (in clock ticks) between the last two commutation steps
volatile uint32_t measuredTicks = 0;

// PID variables
volatile float error = 0.0f;
volatile float errAcum = 0.0f;
volatile float errPrev = 0.0f;
volatile float setpoint = 0.0f;
float DutyMinLim = 0.12f;
float DutyMaxLim = 0.95f;
float TFaseMax;// = 0.6e-3f; // s
float TFaseMin;// = 0.1e-3f; // s
volatile float NoLoadDuty = 0.0f;
volatile float PID_Duty = 0.0f;
volatile uint8_t counter = 0;

// Current Duty Cycle State (Start at a safe middle value, e.g., 14%)
float current_duty_percent = 0.14;

// Controller Limits
#define MIN_DUTY_CLAMP 0.14f // 12%
#define MAX_DUTY_CLAMP 0.22f // 18%

// Comencem apagant tots els MOSFETs
int state = STOP;

uint8_t RiseFall = 0;

// Number of cycles in OL ramp
const int N = 30;

// OL ramp parameter vectors
float freqfase[N + 1];
uint32_t dutys[N + 1];

// Dynamic status variables
volatile int started = 0;
volatile int moving = 1;

uint32_t target_ticks = 0;
uint32_t adc_val = 0;

/**
 * @brief updateClosedLoopState
 */
/*
 void updateClosedLoopState() {//(bool A, bool B, bool C) {

 mosfets.Ph1A(A && !B);
 mosfets.Ph2A(B && !C);
 mosfets.Ph3A(C && !A);

 mosfets.Ph1B(!A && B);
 mosfets.Ph2B(!B && C);
 mosfets.Ph3B(!C && A);
 }
 */

/**
 * @brief updateState
 * Configura sortides de GPIOs pels sis estats d'alimentaci√≥ del motor
 */
void updateState(int state)
{
    switch (state)
    {
    case STOP:
        mosfets.allOff();
        break;

    case S1:
        mosfets.Ph1A(true);
        mosfets.Ph2A(false);
        mosfets.Ph3A(false);

        mosfets.Ph1B(false);
        mosfets.Ph2B(true);
        mosfets.Ph3B(false);
        break;

    case S2:
        mosfets.Ph1A(true);
        mosfets.Ph2A(false);
        mosfets.Ph3A(false);

        mosfets.Ph1B(false);
        mosfets.Ph2B(false);
        mosfets.Ph3B(true);
        break;

    case S3:
        mosfets.Ph1A(false);
        mosfets.Ph2A(true);
        mosfets.Ph3A(false);

        mosfets.Ph1B(false);
        mosfets.Ph2B(false);
        mosfets.Ph3B(true);
        break;

    case S4:
        mosfets.Ph1A(false);
        mosfets.Ph2A(true);
        mosfets.Ph3A(false);

        mosfets.Ph1B(true);
        mosfets.Ph2B(false);
        mosfets.Ph3B(false);
        break;

    case S5:
        mosfets.Ph1A(false);
        mosfets.Ph2A(false);
        mosfets.Ph3A(true);

        mosfets.Ph1B(true);
        mosfets.Ph2B(false);
        mosfets.Ph3B(false);
        break;

    case S6:
        mosfets.Ph1A(false);
        mosfets.Ph2A(false);
        mosfets.Ph3A(true);

        mosfets.Ph1B(false);
        mosfets.Ph2B(true);
        mosfets.Ph3B(false);
        break;
    }
}

void setupNextInterrupt(int currentState)
{
    comps.disableAllInterrupts();
    switch (currentState)
    {
    case STOP: // Equivalent a S6
        comps.configComparatorInt(COMP_1, true, GPIO_RISING_EDGE);
        break; // Phase A rising
    case S1:
        comps.configComparatorInt(COMP_3, true, GPIO_FALLING_EDGE);
        break; // Phase C falling
    case S2:
        comps.configComparatorInt(COMP_2, true, GPIO_RISING_EDGE);
        break; // Phase B rising
    case S3:
        comps.configComparatorInt(COMP_1, true, GPIO_FALLING_EDGE);
        break; // Phase A falling
    case S4:
        comps.configComparatorInt(COMP_3, true, GPIO_RISING_EDGE);
        break; // Phase C rising
    case S5:
        comps.configComparatorInt(COMP_2, true, GPIO_FALLING_EDGE);
        break; // Phase B falling
    case S6:
        comps.configComparatorInt(COMP_1, true, GPIO_RISING_EDGE);
        break; // Phase A rising
    }

    // Clear comparator interrupts
    comps.clearInterrupts();
}

float PID(float cycleTime, float error, float errPrev, float errAcum)
{
    float K_p = 10000.0f;
    float K_i = 30000.0f; //50000.0f; //3*K_p;
    float K_d = 0.0f;

    return K_p * error + K_i * errAcum + K_d * (error - errPrev) / cycleTime;
}

/**
 * Reads the raw comparator states to determine the physical rotor sector (S1-S6).
 * This allows the code to "find" the rotor if it gets lost.
 */
int getRealRotorState(void)
{
    // Read the raw boolean state of the comparators using your existing library
    bool A = comps.readA();
    bool B = comps.readB();
    bool C = comps.readC();

    // Combine into a 3-bit Hall-style code (A | B | C)
    int hallCode = (A << 2) | (B << 1) | (C << 0);

    // Map the 3-bit code to your S1-S6 states based on your commutation table
    switch (hallCode)
    {
    case 5:
        return S1; // 101 -> S1 (Wait for C Fall)
    case 4:
        return S2; // 100 -> S2 (Wait for B Rise)
    case 6:
        return S3; // 110 -> S3 (Wait for A Fall)
    case 2:
        return S4; // 010 -> S4 (Wait for C Rise)
    case 3:
        return S5; // 011 -> S5 (Wait for B Fall)
    case 1:
        return S6; // 001 -> S6 (Wait for A Rise)
    default:
        return -1; // Invalid state (000 or 111)
    }
}

// Reads a TFase value (such as the setpoint) and returns the duty value for no torque
float TFaseToDuty(float TFase)
{
    float instDuty = -6186719601.0f * TFase * TFase * TFase;
    instDuty += 16659072.0f * TFase * TFase;
    instDuty += -15016.0f * TFase + 4.675f;
    return instDuty;
}

void CalculateLimits() {
    // Find TFaseMax (The period corresponding to Min Duty)
    // We scan from 5ms down to 0.1ms until we find the matching duty
    float test_period = 5.0e-3;
    while (test_period > 0.1e-3) {
        if (TFaseToDuty(test_period) >= DutyMinLim) {
            TFaseMax = test_period;
            break;
        }
        test_period -= 0.01e-3; // Decrement by 10us
    }

    // Find TFaseMin (The period corresponding to Max Duty)
    test_period = 5.0e-3;
    while (test_period > 0.1e-3) {
        if (TFaseToDuty(test_period) >= DutyMaxLim) {
            TFaseMin = test_period;
            break;
        }
        test_period -= 0.01e-3;
    }
}

bool cl_locked = false;
volatile int zc_detected_count = 0;

extern void GPIOInt(void)
{
    comps.disableAllInterrupts();

    if (legacy)
    {
        int realState = getRealRotorState();
        // Allow for a +/- 1 state margin of error due to timing, but if it's off by more...
        if (realState != -1 && realState != state
                && realState != (state + 1) % 6)
        //if (realState != state)
        {
            // FORCE RESYNC
            state = realState;
            updateState(state);

            // Count errors
            commutation_error_count++;
        }
        else
        {
            // Decrement errors if all good (to avoid stopping for minor skips)
            if (commutation_error_count > 0)
                commutation_error_count--;
        }
    }

    isr_execution_count++;

    uint32_t timer_current_value = MAP_TimerValueGet(TIMER0_BASE, TIMER_A);

    // The time elapsed is the Load Value minus what is Left
    uint32_t measuredTicks = stallPeriod - timer_current_value;

    if (PID_control)
    {
        float cycleTime = (float) measuredTicks / (float) MAP_SysCtlClockGet(); // Time since last GPIOInt (s)

                // Compute new PID duty from estimated instantaneous duty
                //float inst_x = (float) measuredTicks / MAP_SysCtlClockGet();
                //float instDuty = -6186719601.0f * cycleTime * cycleTime * cycleTime;
                //instDuty += 16659072.0f * cycleTime * cycleTime;
                //instDuty += -15016.0f * cycleTime + 4.675f;

        //error = setpoint - instDuty;
        error = cycleTime - setpoint; // Measured period - intended period: less than intended -> greater speed -> negative error
        errAcum += error * cycleTime;

        if (errAcum > 0.06f)
            errAcum = 0.06f;
        if (errAcum < -0.06f)
            errAcum = -0.06f;
        float PID_Duty = NoLoadDuty + PID(cycleTime, error, errPrev, errAcum);

        //PID_Duty += PID(cycleTime, error, errPrev, errAcum);

        if (PID_Duty > DutyMaxLim)
            (PID_Duty = DutyMaxLim);
        else if (PID_Duty < DutyMinLim)
            (PID_Duty = DutyMinLim);

        uint32_t newDuty = (uint32_t) (PID_Duty * ui32Period);
        mosfets.updateDuty(newDuty);

        // Update previous error
        errPrev = error;

        /*
        if (error < 0.05e-3)
        {
            counter++;

            if (counter >= 10)
            {
                errAcum = 0.0f;
            }
        }
        */
    }

    if (CLOSED_LOOP && started)
    {
        state = (state + 1) % 6;
        updateState(state);

        //MAP_SysCtlDelay(measuredTicks * 0.1 / 3);
        //MAP_SysCtlDelay((MAP_SysCtlClockGet() * 2e-4) / 3);

    }

    // 30 degree delay
    // MAP_SysCtlDelay((MAP_SysCtlClockGet() * 2e-6) / 3);

// Reset stall timer
    MAP_TimerIntDisable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
    MAP_TimerLoadSet(TIMER0_BASE, TIMER_A, stallPeriod);
    MAP_TimerIntEnable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);

// Setup next interrupt
    setupNextInterrupt(state);

    comps.clearInterrupts();
}

void StallInt(void)
{

// Disable timer interrupts
    MAP_TimerIntDisable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);

// Clear int.
    MAP_TimerIntClear(TIMER0_BASE, TIMER_TIMA_TIMEOUT);

// Shut off all mosfets
    mosfets.allOff();

// Wait the stalling grace period
    MAP_SysCtlDelay((MAP_SysCtlClockGet() * 300e-3) / 3);

// Notify of stalling
    moving = 0;
    started = 0;
    state = STOP;

// Re-enable int.
    MAP_TimerIntEnable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
}

//=============================================================================
// MAIN FUNCTION
//=============================================================================
int main(void)
{

// Set the clocking to run directly from the external crystal/oscillator
    MAP_SysCtlClockSet(SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_MAIN |
    SYSCTL_XTAL_16MHZ);
    ui32Period = (uint32_t) (MAP_SysCtlClockGet() / pwm_freq);

// Set the PWM clock to the system clock
    MAP_SysCtlPWMClockSet(SYSCTL_PWMDIV_1);

// Enable FPU
    FPUEnable();
    FPULazyStackingEnable();

// Stall timer setup
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0); // Enable timer
    while (!SysCtlPeripheralReady(SYSCTL_PERIPH_TIMER0))
    {
    }; // Wait for the Timer0 module to be ready
    MAP_TimerConfigure(TIMER0_BASE, TIMER_CFG_PERIODIC); // Configure it as a periodic timer
    stallPeriod = MAP_SysCtlClockGet() * 1; // NO SE PER QUE PERO AIXO FUNCIONA
    MAP_TimerLoadSet(TIMER0_BASE, TIMER_A, stallPeriod); // Set the timer period: in this case, 10ms?
    TimerIntRegister(TIMER0_BASE, TIMER_A, StallInt); // Set up the timeout handling function

// ADC setup
    ADCSetup();

// MOSFET Setup
    float initial_duty = 0.16;
    mosfets.setup(pwm_freq, initial_duty);

// Disable interrupts for setup
    MAP_IntMasterDisable();
    comps.setup(GPIOInt);

    updateState(state); // This will now call mosfets.allOff()

//float phase_period = 4e-3;
    int cyclesPerStep = 32;

    float ini_duty = 0.18;
    float fin_duty = 0.14;
    float ini_fase = 4e-3; // ms
    float fin_fase = 1.5e-3; // ms
// float test_duty = 0.14 / pwm_freq;

// Find the open-loop ramp trajectory
    for (int i = 0; i <= N; i++)
    {
        freqfase[i] = (ini_fase + (fin_fase - ini_fase) * i / N) / 2;
        dutys[i] = (uint32_t) (ui32Period
                * (ini_duty + (fin_duty - ini_duty) * i / N));
    }

    MAP_IntMasterEnable();
    comps.clearInterrupts();
    comps.disableAllInterrupts();

// Start the stalling timer
    MAP_TimerEnable(TIMER0_BASE, TIMER_A);
    if (stall_detect)
    {
        MAP_TimerEnable(TIMER0_BASE, TIMER_A);
        //MAP_TimerIntEnable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
        // setupNextInterrupt(state);
    }

// Variable to track the last seen ISR count
    uint32_t last_isr_count = 0;
// Timeout counter to detect a stall/manual spin
    uint32_t manual_spin_timeout = 0;

    while (1)
    {

        if (!started)
        {
            // Disable interrupts for ramp
            MAP_TimerIntDisable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);

            comps.disableAllInterrupts();
            comps.clearInterrupts();

            moving = 1;

            state = S6;
            updateState(state);
            MAP_SysCtlDelay((MAP_SysCtlClockGet() * 500e-3) / 3); // Hold for 500ms

            // Rampa open loop
            for (int i = 0; i <= N; i++)
            {

                // Update duty
                mosfets.updateDuty(dutys[i]);

                // Wait a few phase cycles for stability
                for (int j = 0; j <= cyclesPerStep; j++)
                {
                    // Advance states
                    state += 1;
                    state %= 6;
                    updateState(state);

                    // Wait the corresponding phase period
                    MAP_SysCtlDelay((MAP_SysCtlClockGet() * freqfase[i]) / 3);

                    if (!moving)
                    {
                        break;
                        //moving = 1;
                    }
                }
                if (!moving)
                {
                    moving = 1;
                    break;
                }

            }
            PID_Duty = fin_duty;
            errAcum = 0.0f;
            started = 1;
        }
        else if (!CLOSED_LOOP)
        {
            state += 1;
            state %= 6;
            updateState(state);

            MAP_SysCtlDelay((MAP_SysCtlClockGet() * freqfase[N]) / 3);
            //setupNextInterrupt(state);
        }
        else
        {
            // A PARTIR D'AQUI CLOSED LOOP

            if (started != 2)
            {
                comps.clearInterrupts();
                MAP_TimerIntClear(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
                MAP_TimerLoadSet(TIMER0_BASE, TIMER_A, stallPeriod);
                measuredTicks = 0;

                setupNextInterrupt(state);
                started = 2;
            }

            if (potentiometer)
            {

                if (PID_control) // Potentiometer sets setpoint
                {
                    setpoint = (TFaseMin - TFaseMax) * (float) ADC0_ReadAvg(5)
                            / 4095.0f + TFaseMax; // Expected phase period
                    NoLoadDuty = TFaseToDuty(setpoint); // Observed duty under no load
                    //float setFloat = (TFaseMin - TFaseMax) * (float) ADC0_ReadAvg(5) / 4095.0 + TFaseMax;
                    //setpoint = setFloat * MAP_SysCtlClockGet(); // This allows us to compare TFase to counted ticks
                }
                else
                {
                    // Direct potentiometer calculation
                    float readDuty = ((float) ADC0_ReadAvg(5) / 4095.0f)
                            * (DutyMaxLim - DutyMinLim) + DutyMinLim;
                    uint32_t newDuty = (uint32_t) (readDuty * ui32Period);

                    mosfets.updateDuty(newDuty);

                    MAP_SysCtlDelay(MAP_SysCtlClockGet() * 10e-3);
                }
            }

            /*if (potentiometer) // && started == 2)
             {
             // 1. DETERMINE TARGET SPEED FROM POTENTIOMETER
             // Map ADC (0-4095) to a Target Period (Time per step in ticks)
             // High ADC = Fast Speed = Low Period
             // Low ADC  = Slow Speed = High Period

             adc_val = ADC0_ReadAvg(5);

             uint32_t min_speed_ticks = 8000;
             uint32_t max_speed_ticks = 3000;

             target_ticks = min_speed_ticks
             - ((adc_val * (min_speed_ticks - max_speed_ticks))
             / 4095);

             // CALCULATE ERROR AND ADJUST DUTY (Integral Control)
             // "Deadband" is a small margin of error (e.g. 2000 ticks) where we don't change anything
             // to prevent the motor from "hunting" (revving up and down).
             if (legacy)
             {
             uint32_t deadband = 50;
             float step_size = 0.0001f; // How fast it reacts. Too big = unstable.

             if (measured_ticks > (target_ticks + deadband))
             {
             // Motor is taking TOO LONG (Too Slow) -> Increase Power
             current_duty_percent += step_size;
             }
             else if (measured_ticks < (target_ticks - deadband))
             {
             // Motor is taking TOO LITTLE TIME (Too Fast) -> Decrease Power
             current_duty_percent -= step_size;
             }

             // Clamping
             if (current_duty_percent > MAX_DUTY_CLAMP)
             current_duty_percent = MAX_DUTY_CLAMP;
             if (current_duty_percent < MIN_DUTY_CLAMP)
             current_duty_percent = MIN_DUTY_CLAMP;
             }

             // Apply new duty
             uint32_t newDuty =
             (uint32_t) (current_duty_percent * ui32Period);
             mosfets.updateDuty(newDuty);

             // Small delay to keep the control loop stable
             MAP_SysCtlDelay(MAP_SysCtlClockGet() * 5e-3);
             }
             */
            if (legacy)
            {
                if (isr_execution_count == last_isr_count)
                {
                    // No interrupts have fired recently -> Potential stall or manual spin
                    manual_spin_timeout++;

                    // If we have been "silent" for enough loop cycles
                    if (manual_spin_timeout > 10)
                    {
                        MAP_IntMasterDisable();
                        comps.disableAllInterrupts();
                        comps.clearInterrupts();

                        mosfets.allOff();
                        state = S6;
                        started = 0;

                        MAP_IntMasterEnable();
                        // Reset timeout so we don't spam the resync
                        manual_spin_timeout = 0;
                    }
                }
                else if (commutation_error_count > 5)
                {
                    // We get interrupts but wrong ones

                    MAP_IntMasterDisable();
                    comps.disableAllInterrupts();
                    comps.clearInterrupts();

                    mosfets.allOff();
                    state = S6;
                    started = 0;

                    // Reset counters
                    manual_spin_timeout = 0;
                    commutation_error_count = 0;
                    last_isr_count = 0;

                    MAP_IntMasterEnable();
                }
                else
                {
                    // Interrupts are firing! The motor is running normally.
                    // Reset the timeout and update our tracker.
                    manual_spin_timeout = 0;
                    last_isr_count = isr_execution_count;
                }
            }

            //while (!cl_locked) {
            // Keep commutating at the final frequency
            //    state = (state + 1) % 6;
            //    updateState(state);
            //    setupNextInterrupt(state); // Ensure comparator is looking for the right edge

            // Wait the phase period from the end of the ramp
            //MAP_SysCtlDelay((MAP_SysCtlClockGet() * freqfase[N]) / 3);

            // If we've seen enough interrupts in the ISR -> stop this manual loop
            //    if (zc_detected_count > 12) { // Wait for 2 full revS
            //        cl_locked = true;
            //    }
            //while (1) {}
        }
    }
}
